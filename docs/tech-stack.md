# Технический стек проекта Deadline Mate

Данный документ предоставляет подробное описание технологий, используемых в проекте Deadline Mate, включая обоснование выбора каждой технологии, архитектурные решения и взаимодействие компонентов системы.

## Обзор архитектуры

Deadline Mate построен на основе современной клиент-серверной архитектуры с четким разделением фронтенда и бэкенда:

- **Бэкенд**: RESTful API на Django с Django REST Framework
- **Фронтенд**: Single Page Application на Next.js (React)
- **База данных**: PostgreSQL
- **Развертывание**: Docker контейнеры с оркестрацией через Docker Compose

Такая архитектура обеспечивает:
- Высокую масштабируемость
- Чёткое разделение ответственности
- Гибкость в выборе технологий для каждого компонента
- Возможность независимой разработки и развертывания фронтенда и бэкенда

## Бэкенд

### Основные технологии

#### Python 3.9+
- **Обоснование выбора**: Python обеспечивает высокую производительность разработки благодаря своей выразительности и читаемости, что особенно важно для учебного проекта. Богатая экосистема библиотек и фреймворков позволяет быстро создавать сложные системы.
- **Применение**: Весь серверный код, бизнес-логика, работа с данными.

#### Django 4.2
- **Обоснование выбора**: Django предоставляет мощный набор инструментов, следуя принципу "включенных батареек", что позволяет быстро разрабатывать надежные веб-приложения с меньшим количеством кода. Используется LTS-версия для обеспечения стабильности.
- **Применение**: Основной фреймворк для бэкенда, управление пользователями, административный интерфейс, ORM, маршрутизация.
- **Ключевые компоненты**:
  - **Django ORM**: для взаимодействия с базой данных
  - **Django Admin**: для быстрого создания административного интерфейса
  - **Django Signals**: для реализации событийно-ориентированной архитектуры
  - **Django Migrations**: для управления схемой базы данных

#### Django REST Framework
- **Обоснование выбора**: DRF предоставляет мощный, но гибкий набор инструментов для построения Web API. Отлично интегрируется с экосистемой Django, обеспечивая сериализацию/десериализацию данных, валидацию, аутентификацию и документирование API.
- **Применение**: Создание RESTful API для взаимодействия с фронтендом.
- **Ключевые компоненты**:
  - **ViewSets и ModelViewSets**: для быстрого создания CRUD API
  - **Serializers**: для преобразования моделей Django в JSON и обратно
  - **Permissions**: для тонкой настройки прав доступа
  - **Pagination**: для постраничного вывода больших наборов данных

#### JWT (JSON Web Tokens)
- **Обоснование выбора**: JWT обеспечивает безопасный способ аутентификации без сохранения состояния на сервере, что важно для API-ориентированных приложений. Это позволяет легко масштабировать систему и улучшает производительность.
- **Применение**: Аутентификация и авторизация пользователей в API.
- **Реализация**: `djangorestframework-simplejwt` для интеграции с DRF.

### Хранение данных

#### PostgreSQL 14
- **Обоснование выбора**: PostgreSQL - надежная, масштабируемая СУБД с отличной поддержкой транзакций, сложных запросов и целостности данных. Поддерживает JSON, что полезно для хранения полуструктурированных данных.
- **Применение**: Основное хранилище данных приложения.
- **Особенности использования**:
  - Индексирование для ускорения поиска
  - Транзакции для обеспечения целостности данных
  - Внешние ключи для связей между таблицами
  - Миграции Django для управления схемой

#### Redis
- **Обоснование выбора**: Redis обеспечивает высокоскоростное кеширование и хранение временных данных, что критично для обеспечения высокой производительности приложения.
- **Применение**: Кеширование, сессии, задачи в очередях, блокировки.
- **Интеграция**: `django-redis` для подключения Redis к Django.

### Другие технологии бэкенда

#### Celery
- **Обоснование выбора**: Celery позволяет эффективно выполнять асинхронные задачи, что необходимо для отправки уведомлений, создания отчетов и других долгих операций без блокирования основного потока обработки запросов.
- **Применение**: Фоновые задачи, отложенная обработка, периодические задачи.
- **Интеграция**: `django-celery-beat` для планирования периодических задач.

#### drf-spectacular
- **Обоснование выбора**: Автоматическая генерация документации API на основе OpenAPI спецификации значительно упрощает разработку и тестирование API.
- **Применение**: Документирование API эндпоинтов, генерация Swagger и ReDoc интерфейсов.

#### Pillow
- **Обоснование выбора**: Библиотека для обработки изображений, которая хорошо интегрируется с Django.
- **Применение**: Обработка загруженных изображений, создание миниатюр, валидация изображений.

#### django-filters
- **Обоснование выбора**: Упрощает создание сложной фильтрации для API эндпоинтов.
- **Применение**: Фильтрация данных на стороне сервера для API.

#### django-cors-headers
- **Обоснование выбора**: Необходимо для обеспечения безопасного взаимодействия между фронтендом и бэкендом при разделении на отдельные сервисы.
- **Применение**: Настройка CORS для API.

### Структура бэкенда

Бэкенд организован в виде модульных Django-приложений, каждое из которых отвечает за определенную функциональную область:

```
backend/
├── deadline_mate/        # Основной проект Django
│   ├── settings/         # Настройки проекта (разделены по окружениям)
│   ├── urls.py           # Корневые URL-маршруты
│   └── wsgi.py           # WSGI-конфигурация
├── authentication/       # Приложение для аутентификации и управления пользователями
├── groups/               # Управление группами студентов
├── assignments/          # Управление заданиями и дедлайнами
├── progress/             # Отслеживание прогресса и оценки
├── notifications/        # Система уведомлений
├── analytics/            # Аналитика и отчеты
└── core/                 # Общие утилиты и функции
```

Каждое приложение следует принципу инкапсуляции и содержит:
- `models.py`: определения моделей данных
- `serializers.py`: сериализаторы DRF
- `views.py`: представления API
- `urls.py`: URL-маршруты приложения
- `admin.py`: настройки административного интерфейса
- `tests/`: модульные и интеграционные тесты

## Фронтенд

### Основные технологии

#### Next.js 13
- **Обоснование выбора**: Next.js обеспечивает отличную производительность благодаря серверному рендерингу (SSR) и статической генерации (SSG), имеет встроенную маршрутизацию и оптимизацию производительности. Это позволяет создавать быстрые и SEO-дружественные приложения.
- **Применение**: Основной фреймворк для фронтенда.
- **Ключевые функции**:
  - **Server-Side Rendering (SSR)**: для улучшения SEO и производительности
  - **API Routes**: для создания серверных эндпоинтов
  - **File-Based Routing**: для упрощения навигации
  - **Image Optimization**: для автоматической оптимизации изображений

#### React 18
- **Обоснование выбора**: React предоставляет компонентный подход к разработке UI, что обеспечивает переиспользуемость кода и модульность. Новые функции React 18, такие как Concurrent Rendering, повышают отзывчивость интерфейса.
- **Применение**: Компонентная архитектура интерфейса.
- **Ключевые функции**:
  - **Hooks**: для управления состоянием и побочными эффектами
  - **Context API**: для глобального состояния без использования сторонних библиотек
  - **Suspense**: для улучшения пользовательского опыта при загрузке

#### TypeScript
- **Обоснование выбора**: TypeScript обеспечивает статическую типизацию, что повышает качество кода, упрощает рефакторинг и предотвращает множество ошибок на этапе компиляции.
- **Применение**: Весь код фронтенда написан на TypeScript.
- **Преимущества**:
  - Строгая типизация для предотвращения ошибок
  - Улучшенная автодополнение в IDE
  - Более понятный и самодокументируемый код

### UI и стилизация

#### Chakra UI
- **Обоснование выбора**: Chakra UI предоставляет готовые, доступные компоненты с поддержкой темизации и отзывчивым дизайном. Компоненты легко кастомизируются и обеспечивают единообразие интерфейса.
- **Применение**: Основная UI-библиотека для компонентов интерфейса.
- **Ключевые компоненты**:
  - **Box, Flex, Grid**: для компоновки элементов
  - **Button, Input, Form**: для интерактивных элементов
  - **Modal, Drawer, Toast**: для всплывающих элементов
  - **Темизация**: для поддержки светлой и темной тем

#### Emotion
- **Обоснование выбора**: CSS-in-JS решение, используемое Chakra UI, которое обеспечивает изоляцию стилей, динамическую стилизацию и поддержку темизации.
- **Применение**: Базовый механизм стилизации компонентов.

#### React Icons
- **Обоснование выбора**: Библиотека с большим набором популярных иконок, которые легко интегрируются в React-приложение.
- **Применение**: Иконки для UI элементов.

### Управление состоянием и данными

#### React Context API
- **Обоснование выбора**: Встроенное в React решение для глобального управления состоянием, которое не требует дополнительных зависимостей и хорошо подходит для приложений среднего размера.
- **Применение**: Управление глобальным состоянием приложения, разделенным по функциональным областям.
- **Контексты**:
  - `AuthContext`: для управления аутентификацией
  - `GroupContext`: для работы с группами
  - `AssignmentContext`: для управления заданиями
  - `ThemeContext`: для управления темой

#### Axios
- **Обоснование выбора**: Популярная библиотека для HTTP-запросов с удобным API, поддержкой интерцепторов и обработкой ошибок.
- **Применение**: Взаимодействие с API бэкенда.
- **Особенности использования**:
  - Интерцепторы для добавления токенов аутентификации
  - Централизованная обработка ошибок
  - Типизация ответов с помощью TypeScript

### Интернационализация

#### next-i18next
- **Обоснование выбора**: Интеграция i18next с Next.js, которая обеспечивает простую локализацию приложения с поддержкой SSR.
- **Применение**: Мультиязычность приложения (русский и английский языки).
- **Особенности**:
  - JSON-файлы локализации
  - Контекстные переводы
  - Поддержка переменных в переводах

### Другие технологии фронтенда

#### React Hook Form
- **Обоснование выбора**: Библиотека для управления формами, которая минимизирует количество перерендеров и упрощает валидацию.
- **Применение**: Сложные формы с валидацией.

#### date-fns
- **Обоснование выбора**: Легковесная библиотека для работы с датами, которая поддерживает интернационализацию и имеет модульную структуру.
- **Применение**: Форматирование дат, расчет временных интервалов.

#### React Query
- **Обоснование выбора**: Библиотека для управления состоянием данных с сервера, которая обеспечивает кеширование, фоновую синхронизацию и оптимистичные обновления.
- **Применение**: Управление серверным состоянием, кеширование запросов.

### Структура фронтенда

Фронтенд организован в соответствии с принципами компонентного подхода и соглашениями Next.js:

```
frontend/
├── public/                # Статические файлы
│   ├── locales/           # Файлы локализации
│   │   ├── en/            # Английский язык
│   │   └── ru/            # Русский язык
│   └── images/            # Изображения
├── src/
│   ├── pages/             # Страницы приложения (маршрутизация Next.js)
│   │   ├── api/           # API-маршруты Next.js
│   │   ├── assignments/   # Страницы для заданий
│   │   ├── groups/        # Страницы для групп
│   │   └── ...            # Другие страницы
│   ├── components/        # Переиспользуемые компоненты
│   │   ├── common/        # Общие компоненты (кнопки, поля ввода и т.д.)
│   │   ├── layout/        # Компоненты макета (хедер, футер, сайдбар)
│   │   ├── assignments/   # Компоненты, связанные с заданиями
│   │   ├── groups/        # Компоненты, связанные с группами
│   │   └── ...            # Другие компоненты
│   ├── contexts/          # Контексты React для глобального состояния
│   ├── hooks/             # Пользовательские хуки
│   ├── utils/             # Утилиты и вспомогательные функции
│   └── styles/            # Глобальные стили и темы
└── next.config.js         # Конфигурация Next.js
```

## Инфраструктура и DevOps

### Контейнеризация

#### Docker
- **Обоснование выбора**: Docker обеспечивает изоляцию приложения и его зависимостей, упрощает развертывание и масштабирование, а также устраняет проблемы "работает на моем компьютере".
- **Применение**: Контейнеризация всех компонентов приложения.
- **Контейнеры**:
  - **backend**: Django-приложение
  - **frontend**: Next.js-приложение
  - **db**: PostgreSQL
  - **redis**: Redis для кеширования и очередей
  - **nginx**: Веб-сервер и обратный прокси

#### Docker Compose
- **Обоснование выбора**: Docker Compose упрощает управление мультиконтейнерными приложениями, определяя сервисы, сети и тома в одном YAML-файле.
- **Применение**: Оркестрация контейнеров для локальной разработки и тестирования.

### Непрерывная интеграция и развертывание

#### GitHub Actions
- **Обоснование выбора**: Интеграция CI/CD прямо в GitHub, что упрощает автоматизацию процессов разработки.
- **Применение**: Автоматический запуск тестов, линтинг, сборка и развертывание.
- **Пайплайны**:
  - **test**: запуск тестов при каждом push и pull request
  - **build**: сборка Docker-образов
  - **deploy**: развертывание на тестовой и продакшн-средах

### Мониторинг и логирование

#### Prometheus и Grafana
- **Обоснование выбора**: Prometheus эффективно собирает метрики, а Grafana предоставляет мощные инструменты для их визуализации.
- **Применение**: Мониторинг производительности и доступности приложения.

#### ELK Stack (Elasticsearch, Logstash, Kibana)
- **Обоснование выбора**: Полнофункциональное решение для сбора, анализа и визуализации логов.
- **Применение**: Централизованное логирование всех компонентов системы.

## Безопасность

### Основные меры безопасности

#### HTTPS
- **Обоснование выбора**: Шифрование передаваемых данных для защиты от перехвата.
- **Применение**: Все взаимодействие между клиентом и сервером.

#### OWASP Рекомендации
- **Обоснование выбора**: OWASP Top 10 - стандартный набор рекомендаций по защите от наиболее распространенных уязвимостей.
- **Применение**: 
  - Защита от XSS с помощью CSP и экранирования
  - Защита от CSRF с использованием токенов
  - Правильная аутентификация и авторизация
  - Параметризованные запросы для защиты от SQL-инъекций

#### Хеширование паролей
- **Обоснование выбора**: Современные алгоритмы хеширования защищают пароли пользователей даже в случае компрометации базы данных.
- **Применение**: bcrypt с солью и дополнительными итерациями.

## Тестирование

### Типы тестов

#### Модульные тесты
- **Обоснование выбора**: Проверка отдельных единиц кода в изоляции для раннего выявления проблем.
- **Применение**: Тестирование отдельных функций, компонентов и моделей.
- **Инструменты**: 
  - **Backend**: pytest
  - **Frontend**: Jest, React Testing Library

#### Интеграционные тесты
- **Обоснование выбора**: Проверка взаимодействия между компонентами системы.
- **Применение**: Тестирование API, взаимодействия с базой данных.
- **Инструменты**: pytest-django, SuperTest

#### E2E тесты
- **Обоснование выбора**: Проверка всего пользовательского пути от начала до конца.
- **Применение**: Симуляция действий пользователя через UI.
- **Инструменты**: Cypress

## Рабочий процесс разработки

### Git Flow
- **Обоснование выбора**: Структурированный подход к ветвлению в Git, который упрощает параллельную разработку и релизы.
- **Применение**: 
  - **main**: стабильная версия проекта
  - **develop**: основная ветка разработки
  - **feature/xxx**: ветки для новых функций
  - **bugfix/xxx**: ветки для исправления ошибок
  - **release/xxx**: ветки для подготовки релиза

### Code Review
- **Обоснование выбора**: Процесс проверки кода другими разработчиками для повышения качества и обмена знаниями.
- **Применение**: Обязательное ревью всех pull request перед слиянием.

### Автоматизация
- **Обоснование выбора**: Автоматизация рутинных задач для повышения эффективности разработки.
- **Применение**: 
  - Pre-commit хуки для линтинга и форматирования
  - Автоматическое тестирование при push
  - Автоматическое развертывание при слиянии в основную ветку

## Развертывание

### Среды
- **Development**: локальная среда разработчика
- **Staging**: тестовая среда, максимально приближенная к production
- **Production**: продакшн-среда для конечных пользователей

### Конфигурация
- **Обоснование выбора**: Разделение конфигурации по средам для обеспечения безопасности и гибкости.
- **Применение**: 
  - Переменные окружения для чувствительных данных
  - Различные настройки для разных сред
  - Управление конфигурацией через Docker Compose

## Заключение

Технический стек Deadline Mate основан на современных, проверенных технологиях, которые обеспечивают гибкость, масштабируемость и удобство разработки. Архитектура проекта позволяет независимо развивать и масштабировать отдельные компоненты, что делает систему устойчивой к изменениям требований и росту нагрузки.

Выбор технологий основан на следующих принципах:
1. **Соответствие требованиям**: каждая технология выбрана с учетом конкретных требований проекта
2. **Зрелость и поддержка**: предпочтение отдано проверенным технологиям с активной поддержкой
3. **Экосистема**: важную роль играет наличие готовых решений и интеграций
4. **Порог входа**: учитывается простота освоения для новых участников проекта
5. **Масштабируемость**: возможность масштабирования при росте проекта

Техстек постоянно оценивается и актуализируется для обеспечения лучшего пользовательского опыта и эффективности разработки. 